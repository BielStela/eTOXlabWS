package controllers

import play.api._
import play.api.mvc._
import java.io.File
import scala.io.Source._
import play.api.libs.json._
import play.api.data.Forms
import play.api.data.Form
import scala.sys.process._
import scala.collection.mutable.LinkedList
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files
import com.typesafe.config.Config
import com.typesafe.config.ConfigFactory

object Application extends Controller {
  val conf = ConfigFactory.load()
  val etoxlabhome = conf.getString("etoxlabhome")
  val modeldir = etoxlabhome + "/src"
  val envoy_ws_home = conf.getString("envoy_ws_home")
  val tempPath: Path = Paths.get(envoy_ws_home + "/temp")

  def readFile(file: File) = scala.io.Source.fromFile(file).getLines.take(1).reduceLeft(_ + _)

  def callPredictEtoxLab(model: String, fileCmps: String) = Seq("/usr/bin/python", modeldir + "/predict.py", "-e", model, "-a", "-f", fileCmps, "-b")

  def getTmpFile(tmpDir: Path, extension: String) =
    {
      val tdir = tmpDir.toAbsolutePath().toString()
      println("Temp!")
      println(tmpDir.toAbsolutePath().toString())
      val tfile = tdir + "/input_file" + extension
      tfile
    }

  def read_models =
    {
      println("Read Models")

      def listDirs(f: File): Array[File] = f.listFiles.filter(_.isDirectory)

      println(modeldir)
      val lf = listDirs(new File(modeldir))

      println("---------")
      val models2 = for (f <- lf.map(_.getAbsoluteFile()) if new File(f.getAbsoluteFile() + "/service-label.txt").exists())
        yield ({
        println("File: " + f.getAbsoluteFile())
        val st = readFile(new File(f.getAbsoluteFile() + "/service-label.txt"))
        (f.getName(), st)
      })

      models2.map(println)

      println("---------")
      //      val files = lf.map(_.getAbsoluteFile()).filter(_.getName().contains("service-label.txt"))
      //      println(files.size)
      //      val models = for (file <- files)
      //        yield (readFile(file) -> file.getAbsoluteFile().getAbsolutePath())
      //      println("Models")
      //      models.map(a => println(a._1, a._2))
      models2
    }

  def info = Action {
    val infores = Map("provider" -> "FIMIM", "homepage" -> "http://phi.imim.es", "admin" -> "Manuel Pastor", "admin-email" -> "manuel.pastor@upf.edu")
    val js = Json.toJson(infores)
    Ok(js)
  }

  def getModels = Action {
    val js = Json.toJson((Map("predictions" -> read_models.map(_._1))))
    Ok(js)
  }
  def predictForm = Action {
    println(".................")
    for (model <- Application.read_models)
      println(model._1, model._2)
    println(".................")
    Ok(views.html.main("Your new application is ready."))
  }
  def getCurrentDirectory = new java.io.File(".").getCanonicalPath

  def parseResults(file: String) = {
    val itype = "quantitative"
    var i = 0
    val resultLines = for (line <- scala.io.Source.fromFile(file).getLines) yield ({
      println(line)
      val fields = line.split('\t')
      fields.map(println)
      val result = fields.length match {
        case 6 => {
          val valueResult =
            if (fields(0) == "1")
              Map("success" -> "True", "value" -> fields(1))
            else
              Map("success" -> "False", "message" -> fields(1))

          val adResult =
            if (fields(2) == "1")
              Map("success" -> "True", "value" -> fields(3), "message" -> "")
            else
              Map("success" -> "False", "message" -> fields(3))

          val riResult =
            if (fields(4) == "1")
              Map("success" -> "True", "value" -> fields(5), "message" -> "")
            else
              Map("success" -> "False", "message" -> fields(5))

          val jsResult = Json.toJson(valueResult)
          val resResult = jsResult.toString

          val jsAD = Json.toJson(adResult)
          val resAD = "{\"AD\":" + jsAD.toString + "}"

          val jsRI = Json.toJson(riResult)
          val resRI = "{\"RI\":" + jsRI.toString + "}"
          println(resResult)
          println(resAD)
          println(resRI)
          resResult.drop(1).dropRight(1) + "," + resAD.drop(1).dropRight(1) + "," + resRI.drop(1).dropRight(1)
        }
        case _ => {
          val mp = Map("value" -> "", "success" -> "False", "message" -> "unknown error")
          Json.toJson(mp).toString
        }
      }
      val resultLine = "{\"cmp_id\":\"" + i.toString + "\"," + result + "}"
      i += 1
      resultLine
    })
    "[" + resultLines.mkString(",") + "]"
  }

  def webTagToModel(webTag:String)={
    val mp=this.read_models.map(a=>(a._2,a._1)).toMap
    mp(webTag)
  }
  def getPrediction = Action(parse.multipartFormData) { request =>
    val tmpDir: Path = Files.createTempDirectory(tempPath, null)
    val form = request.body.asFormUrlEncoded

    val ufile = request.body.file("uploadfile")
    val ufile2 = ufile.get

    val filename = ufile2.filename
    val contentType = ufile2.contentType
    val tmpFile = getTmpFile(tmpDir, ".sdf")
    ufile2.ref.moveTo(new File(tmpFile), replace = true)

    val modeltag = form.get("model").get.head

    val f = new File(tmpDir.toAbsolutePath().toString())

    val p = Process(callPredictEtoxLab(webTagToModel(modeltag), tmpFile), cwd = Some(f))
    
    println(callPredictEtoxLab(webTagToModel(modeltag), tmpFile))
    val q = p.!

    val res = parseResults(tmpDir.toAbsolutePath().toString() + "/result.txt")
    val p2 = Seq("rm", "-Rf", tmpDir.toAbsolutePath().toString())
    //p2!

    Ok(res).as("application/json")
  }

}